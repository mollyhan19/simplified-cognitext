
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <script src="https://d3js.org/d3.v7.min.js"></script>
            <style>
                body {
                    font-family: Arial, sans-serif;
                    margin: 0;
                    overflow: hidden;
                }
                .explanation-panel {
                    position: absolute;
                    padding: 15px;
                    background: white;
                    border: 1px solid #ccc;
                    border-radius: 8px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                    max-width: 300px;
                    z-index: 1000;
                    font-size: 14px;
                    line-height: 1.4;
                    opacity: 0;
                    transition: opacity 0.3s;
                    pointer-events: auto;
                }
                
                .explanation-panel.visible {
                    opacity: 1;
                }
                
                .explanation-title {
                    margin-top: 0;
                    margin-bottom: 10px;
                    color: #2196F3;
                    font-size: 16px;
                    font-weight: bold;
                }
                
                .explanation-content {
                    margin-bottom: 10px;
                }
                
                .explanation-footer {
                    display: block;
                    margin-top: 8px;
                    font-style: italic;
                    color: #666;
                    font-size: 12px;
                }
                
                .close-explanation {
                    position: absolute;
                    top: 5px;
                    right: 5px;
                    background: none;
                    border: none;
                    font-size: 16px;
                    cursor: pointer;
                    color: #666;
                }
                .node {
                    cursor: pointer;
                }
                .node circle {
                    stroke-width: 2px;
                    transition: all 0.3s ease;
                }
                .node.has-explanation circle {
                    stroke-dasharray: 3, 3;
                }
                .node--pinned circle {
                    stroke-width: 3px;
                    stroke-dasharray: none;
                    stroke: #f06292;
                }
                .node--priority circle {
                    stroke: #7E57C2;
                }
                .node--secondary circle {
                    stroke: #6596B5;
                }
                .node--tertiary circle {
                    stroke: #8FC2B9;
                }
                .hidden-connections-highlight {
                    stroke: #FF8A65 !important;
                    stroke-width: 3px !important;
                }
                .node--expanded circle {
                    stroke-width: 3px;
                }
                .node text {
                    font: 12px sans-serif;
                    pointer-events: none;
                }
                .node.faded circle {
                    opacity: 0.2;
                    transition: opacity 0.2s ease;
                }
                
                .node.faded text {
                    opacity: 0.1;
                    transition: opacity 0.2s ease;
                }
                
                .link.faded {
                    opacity: 0.1;
                    transition: opacity 0.2s ease;
                }
                
                .node.focused circle {
                    stroke-width: 4px;
                    stroke: #FF5252;
                }
                .link {
                    fill: none;
                    stroke-width: 1.5px;
                    cursor: pointer;
                    transition: stroke 0.3s ease;
                }
                .link:hover {
                    stroke-width: 2.5px;
                    stroke-opacity: 0.9 !important;
                }
                .link-label {
                    font-size: 10px;
                    fill: #666;
                    pointer-events: none;
                }
                .tooltip {
                    position: absolute;
                    padding: 8px;
                    background: rgba(255, 255, 255, 0.95);
                    color: #333;
                    border-radius: 4px;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
                    pointer-events: none;
                    font-size: 12px;
                    max-width: 300px;
                    z-index: 1000;
                    border: 1px solid #ddd;
                }
                .evidence-tooltip {
                    max-width: 350px;
                    line-height: 1.4;
                }
                .tooltip .right-click-instruction {
                    display: block;
                    margin-top: 5px;
                    font-style: italic;
                    color: #2196F3;
                }
                .legend {
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    background: rgba(255, 255, 255, 0.8);
                    border-radius: 4px;
                    padding: 8px;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
                }
                .legend-item {
                    display: flex;
                    align-items: center;
                    margin-bottom: 5px;
                }
                .legend-color {
                    width: 15px;
                    height: 15px;
                    border-radius: 50%;
                    margin-right: 8px;
                }
                .priority-color {
                    background-color: #9575CD;
                    border: 1.5px solid #7E57C2;
                }
                .secondary-color {
                    background-color: #97C0DB;
                    border: 1.5px solid #6596B5;
                }
                .tertiary-color {
                    background-color: #D1EDE8;
                    border: 1.5px solid #ABD9D1;
                }
                @keyframes pulse-1741365886561 {
                    0% { transform: scale(1); opacity: 0.5; }
                    50% { transform: scale(1.2); opacity: 0.2; }
                    100% { transform: scale(1); opacity: 0.5; }
                }
                .pulse-1741365886561 {
                    animation: pulse-1741365886561 2s infinite;
                }
                .pulse-ring.faded {
                    opacity: 0.01 !important;
                }
                .controls {
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    display: flex;
                    gap: 10px;
                }
                button {
                    background-color: white;
                    border: 1px solid #ccc;
                    border-radius: 4px;
                    padding: 5px 10px;
                    cursor: pointer;
                    font-size: 12px;
                }
                button:hover {
                    background-color: #f0f0f0;
                }
                .center-node circle {
                    stroke-width: 3px;
                }
                .highlight {
                    font-weight: bold;
                    color: #006400;
                }
            </style>
        </head>
        <body>
            <div class="controls">
                <button id="reset-btn">Reset</button>
                <button id="expand-all-btn">Expand All</button>
                <button id="recenter-btn">Recenter</button>
                <button id="unpin-btn">Unpin All</button>
            </div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color priority-color"></div>
                    <span>Priority Concepts</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color secondary-color"></div>
                    <span>Secondary Concepts</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color tertiary-color"></div>
                    <span>Tertiary Concepts</span>
                </div>
                <div class="legend-item">
                    <div style="width:15px; height:15px; margin-right:8px; border:1.5px solid #FF8A65; border-radius:50%; background-color: rgba(255, 0, 0, 0.3);" class="pulse-1741365886561"></div>
                    <span>Has Hidden Connections</span>
                </div>
            </div>

            <svg id="concept-map" width="800" height="600"></svg>
            <div id="tooltip" class="tooltip" style="display: none;"></div>
            <div id="evidence-tooltip" class="tooltip evidence-tooltip" style="display: none;"></div>

            <script>
            // Load the data
            const networkData = {"nodes": [{"id": "quantum supremacy", "name": "quantum supremacy", "frequency": 7, "degree": 30, "layer": "priority", "evidence": "Quantum supremacy refers to the ability of a quantum computer to solve problems that classical computers cannot solve in a reasonable timeframe. This concept is significant as it represents a key milestone in the development of quantum computing, showcasing its potential advantages over classical systems."}, {"id": "boson sampling", "name": "boson sampling", "frequency": 3, "degree": 13, "layer": "priority", "evidence": "Boson sampling is a specific quantum computing task proposed to demonstrate quantum supremacy. It involves sampling from the output of quantum states of indistinguishable particles, showcasing the unique capabilities of quantum systems compared to classical ones."}, {"id": "quantum random circuit sampling", "name": "quantum random circuit sampling", "frequency": 2, "degree": 4, "layer": "secondary", "evidence": "Quantum random circuit sampling is another approach to demonstrate quantum supremacy, where quantum circuits are randomly generated and their outputs are sampled. This method highlights the potential of quantum computers to perform tasks that are infeasible for classical computers."}, {"id": "classical computers", "name": "classical computers", "frequency": 2, "degree": 3, "layer": "secondary", "evidence": "Classical computers are traditional computing systems that operate on classical physics principles. Their ongoing improvements pose challenges to the permanence of quantum supremacy, as advancements in classical algorithms could diminish the advantages of quantum computing."}, {"id": "quantum computing", "name": "quantum computing", "frequency": 2, "degree": 18, "layer": "priority", "evidence": "Quantum Computing is a type of computation that utilizes quantum mechanics to process information in fundamentally different ways than classical computers. It has the potential to solve certain problems much faster than classical computers, making it a significant area of research in computer science."}, {"id": "qubits", "name": "qubits", "frequency": 2, "degree": 2, "layer": "priority", "evidence": "Qubits, or quantum bits, are the fundamental units of quantum information, analogous to classical bits but capable of representing and processing information in ways that classical bits cannot. The number of qubits in a quantum system is crucial because it directly affects the computational power and complexity of quantum algorithms."}, {"id": "john preskill", "name": "john preskill", "frequency": 1, "degree": 3, "layer": "tertiary", "evidence": "John Preskill is a prominent theoretical physicist known for coining the term 'quantum supremacy.' His contributions are crucial in defining the capabilities of quantum computers and distinguishing them from classical computers, thereby shaping the discourse around quantum computing."}, {"id": "yuri manin", "name": "yuri manin", "frequency": 1, "degree": 1, "layer": "tertiary", "evidence": "Yuri Manin is known for his early contributions to the theoretical foundations of quantum computing, dating back to 1980. His work laid the groundwork for later developments in the field, including the concept of quantum supremacy."}, {"id": "richard feynman", "name": "richard feynman", "frequency": 1, "degree": 3, "layer": "tertiary", "evidence": "Richard Feynman was a renowned physicist whose insights into quantum mechanics and computing have significantly influenced the development of quantum computing. His work emphasized the need for quantum computers to simulate quantum phenomena effectively."}, {"id": "computational complexity theory", "name": "computational complexity theory", "frequency": 1, "degree": 3, "layer": "secondary", "evidence": "Computational complexity theory studies the resources required to solve computational problems. It is essential for understanding the implications of quantum supremacy, as it helps identify problems that quantum computers can solve more efficiently than classical ones."}, {"id": "aaronson and arkhipov", "name": "aaronson and arkhipov", "frequency": 1, "degree": 2, "layer": "tertiary", "evidence": "Scott Aaronson and Alex Arkhipov are researchers who proposed the boson sampling experiment as a method to demonstrate quantum supremacy. Their work has been influential in the field of quantum computing and has sparked further research into practical implementations."}, {"id": "near-term quantum computers", "name": "near-term quantum computers", "frequency": 1, "degree": 3, "layer": "secondary", "evidence": "Near-term quantum computers refer to the current generation of quantum devices that may achieve quantum supremacy without needing advanced error correction. This is significant as it suggests that practical demonstrations of quantum advantage may be closer than previously thought."}, {"id": "scientific goal", "name": "scientific goal", "frequency": 1, "degree": 1, "layer": "secondary", "evidence": "Viewing quantum supremacy as a scientific goal emphasizes its role in advancing our understanding of quantum mechanics and computing, rather than focusing solely on immediate commercial applications. This perspective is important for guiding research priorities in the field."}, {"id": "turing machine", "name": "turing machine", "frequency": 1, "degree": 3, "layer": "priority", "evidence": "A Turing machine is a theoretical construct that defines a simple abstract computational device capable of performing any computation that can be algorithmically defined. It is fundamental in the field of computer science as it provides a model for understanding the limits of what can be computed."}, {"id": "shor's algorithm", "name": "shor's algorithm", "frequency": 1, "degree": 14, "layer": "priority", "evidence": "Shor's algorithm is a quantum algorithm designed for integer factorization, which can solve this problem in polynomial time, unlike classical algorithms. Its significance lies in its potential to break widely used cryptographic systems, making it a cornerstone of quantum computing research."}, {"id": "quantum logic gate", "name": "quantum logic gate", "frequency": 1, "degree": 3, "layer": "priority", "evidence": "A quantum logic gate is a basic building block of quantum circuits, analogous to classical logic gates in traditional computing. They manipulate quantum bits (qubits) and are essential for performing quantum computations."}, {"id": "grover's algorithm", "name": "grover's algorithm", "frequency": 1, "degree": 3, "layer": "priority", "evidence": "Grover's Algorithm is a quantum algorithm that provides a quadratic speedup for unstructured search problems compared to classical algorithms. It highlights the advantages of quantum computing in solving specific types of problems more efficiently."}, {"id": "quantum turing machine", "name": "quantum turing machine", "frequency": 1, "degree": 3, "layer": "secondary", "evidence": "A quantum Turing machine extends the classical Turing machine concept to incorporate quantum mechanics, allowing it to process information in ways that classical machines cannot. This concept is crucial for understanding the theoretical foundations of quantum computing."}, {"id": "reversible nature of quantum computing", "name": "reversible nature of quantum computing", "frequency": 1, "degree": 1, "layer": "secondary", "evidence": "The reversible nature of quantum computing refers to the ability to reverse quantum operations without loss of information, which is a key principle that allows quantum computers to perform computations more efficiently than classical computers."}, {"id": "quantum algorithm", "name": "quantum algorithm", "frequency": 1, "degree": 6, "layer": "secondary", "evidence": "A quantum algorithm is an algorithm that runs on a quantum computer, utilizing quantum bits and principles of quantum mechanics to solve problems. The implementation of quantum algorithms is essential for demonstrating the practical capabilities of quantum computing."}, {"id": "alan turing", "name": "alan turing", "frequency": 1, "degree": 1, "layer": "tertiary", "evidence": "Alan Turing was a pioneering mathematician and computer scientist whose work laid the foundations for modern computing. His contributions, particularly the concept of the Turing machine, are fundamental to the field of computer science."}, {"id": "paul benioff", "name": "paul benioff", "frequency": 1, "degree": 2, "layer": "tertiary", "evidence": "Paul Benioff is known for his contributions to the theoretical foundations of quantum computing, particularly in demonstrating how classical computing concepts can be adapted to quantum systems."}, {"id": "david deutsch", "name": "david deutsch", "frequency": 1, "degree": 2, "layer": "tertiary", "evidence": "David Deutsch is a physicist and computer scientist recognized for his foundational work in quantum computing, including the concept of the quantum Turing machine, which is essential for understanding quantum computation."}, {"id": "christopher monroe and david wineland", "name": "christopher monroe and david wineland", "frequency": 1, "degree": 1, "layer": "tertiary", "evidence": "Christopher Monroe and David Wineland are physicists known for their experimental work in quantum computing, particularly in demonstrating quantum logic gates, which are crucial for building quantum computers."}, {"id": "jonathan a. jones and michele mosca", "name": "jonathan a. jones and michele mosca", "frequency": 1, "degree": 1, "layer": "tertiary", "evidence": "Jonathan A. Jones and Michele Mosca are researchers who contributed to the practical implementation of quantum algorithms, showcasing the capabilities of quantum computers in solving complex problems."}, {"id": "shor's theorem", "name": "shor's theorem", "frequency": 1, "degree": 1, "layer": "priority", "evidence": "Shor's theorem is a quantum algorithm that efficiently factors large integers, which is a task that is computationally intensive for classical computers. This theorem is crucial because it highlights the potential of quantum computing to break widely used cryptographic systems, thereby reshaping the landscape of cybersecurity."}, {"id": "deutsch's algorithm", "name": "deutsch's algorithm", "frequency": 1, "degree": 1, "layer": "priority", "evidence": "Deutsch's algorithm is one of the first quantum algorithms that demonstrates the power of quantum computation over classical computation. It solves a specific problem faster than any classical algorithm, showcasing the fundamental differences in processing capabilities between quantum and classical systems."}, {"id": "d-wave systems", "name": "d-wave systems", "frequency": 1, "degree": 0, "layer": "secondary", "evidence": "D-Wave Systems is a company known for developing quantum computers, particularly focusing on quantum annealing technology. Their commercial availability of quantum computers represents a significant step in making quantum computing accessible for practical applications in various industries."}, {"id": "ibm's response", "name": "ibm's response", "frequency": 1, "degree": 0, "layer": "tertiary", "evidence": "IBM's response to Google's claims of quantum supremacy highlights the ongoing debate and scrutiny within the quantum computing community regarding the validity of such claims. This context is essential for understanding the competitive landscape and the challenges in establishing benchmarks for quantum performance."}, {"id": "jiuzhang", "name": "jiuzhang", "frequency": 1, "degree": 1, "layer": "secondary", "evidence": "Jiuzhang is a photonic quantum computer that achieved quantum supremacy through gaussian boson sampling, demonstrating the potential of light-based quantum computing. This achievement is significant as it showcases an alternative approach to quantum computing that could lead to advancements in computational capabilities."}, {"id": "quantum annealing", "name": "quantum annealing", "frequency": 1, "degree": 5, "layer": "secondary", "evidence": "Quantum annealing is a quantum computing method used to find the global minimum of a function, particularly useful for optimization problems. Its significance lies in its ability to solve complex problems more efficiently than classical approaches, thereby demonstrating the practical applications of quantum computing."}, {"id": "neven's law", "name": "neven's law", "frequency": 1, "degree": 1, "layer": "tertiary", "evidence": "Neven's law is a conjecture that predicts the rapid advancement of quantum computing capabilities, suggesting that the performance of quantum computers will improve exponentially over time. This concept is relevant as it frames the expectations and timelines for achieving quantum supremacy."}, {"id": "quantum phase transition", "name": "quantum phase transition", "frequency": 1, "degree": 3, "layer": "secondary", "evidence": "A quantum phase transition refers to a transformation between different quantum states of matter at absolute zero temperature, driven by quantum fluctuations. Understanding this concept is crucial for exploring the behavior of quantum systems and their applications in quantum computing."}, {"id": "complexity arguments", "name": "complexity arguments", "frequency": 1, "degree": 1, "layer": "priority", "evidence": "Complexity arguments are essential in computer science as they help to understand how the resources required to solve problems increase with the size of the input. This understanding is crucial for evaluating the efficiency of algorithms and the feasibility of solving larger problems."}, {"id": "quantum complexity theory", "name": "quantum complexity theory", "frequency": 1, "degree": 3, "layer": "priority", "evidence": "Quantum complexity theory extends classical complexity theory by exploring the capabilities of quantum computers. It is significant because it helps to identify problems that can be solved more efficiently with quantum algorithms compared to classical ones, potentially leading to breakthroughs in computation."}, {"id": "bqp (bounded-error quantum polynomial time)", "name": "bqp (bounded-error quantum polynomial time)", "frequency": 1, "degree": 0, "layer": "priority", "evidence": "BQP is a critical concept in quantum computing as it defines the class of problems that quantum computers can solve efficiently. Understanding BQP is vital for researchers to explore the limits of quantum computation and its implications for classical complexity theory."}, {"id": "circuit model", "name": "circuit model", "frequency": 1, "degree": 2, "layer": "secondary", "evidence": "The circuit model is a foundational concept in both classical and quantum computing, representing how computations are structured. It is important for understanding how different types of operations can be combined to solve complex problems."}, {"id": "quantum gates", "name": "quantum gates", "frequency": 1, "degree": 2, "layer": "secondary", "evidence": "Quantum gates are the building blocks of quantum circuits, allowing for the manipulation of quantum states. Their infinite nature compared to classical gates highlights the unique capabilities of quantum computing, which can lead to more powerful algorithms."}, {"id": "sampling problems", "name": "sampling problems", "frequency": 1, "degree": 3, "layer": "secondary", "evidence": "Sampling problems are a distinct category in computational complexity that focus on generating samples from distributions rather than making binary decisions. They are important for understanding the limits of classical versus quantum computation, especially in the context of quantum supremacy."}, {"id": "quantum complexity classes", "name": "quantum complexity classes", "frequency": 1, "degree": 2, "layer": "secondary", "evidence": "Quantum complexity classes categorize problems based on their computational requirements in a quantum context. Understanding these classes helps researchers identify which problems can benefit from quantum computing and how they relate to classical complexity classes."}, {"id": "historical context", "name": "historical context", "frequency": 1, "degree": 2, "layer": "tertiary", "evidence": "The historical context of quantum computing involves ongoing debates about its capabilities compared to classical computing. This context is crucial for understanding the evolution of computational theory and the significance of quantum advancements."}, {"id": "google and ustc research groups", "name": "google and ustc research groups", "frequency": 1, "degree": 3, "layer": "tertiary", "evidence": "The work of the Google and USTC research groups in Random Circuit Sampling is a notable example of practical applications of quantum computing. Their research contributes to the ongoing exploration of quantum supremacy and the capabilities of quantum algorithms."}, {"id": "prime factorization", "name": "prime factorization", "frequency": 1, "degree": 3, "layer": "priority", "evidence": "Prime factorization is the process of decomposing an integer into a product of prime numbers. It is a fundamental concept in number theory and has significant implications in cryptography, particularly in the security of systems like RSA."}, {"id": "rsa cryptosystem", "name": "rsa cryptosystem", "frequency": 1, "degree": 2, "layer": "priority", "evidence": "The RSA cryptosystem is a widely used public-key cryptographic system that relies on the difficulty of factoring large integers. Its security is based on the assumption that no efficient classical algorithm exists for prime factorization, making Shor's algorithm a significant threat to its security."}, {"id": "superpolynomial speedup", "name": "superpolynomial speedup", "frequency": 1, "degree": 2, "layer": "secondary", "evidence": "Superpolynomial speedup refers to an algorithm's ability to solve a problem significantly faster than the best known classical algorithms, particularly in terms of time complexity. This concept is crucial in understanding the advantages of quantum algorithms over classical ones."}, {"id": "integer factoring", "name": "integer factoring", "frequency": 1, "degree": 3, "layer": "secondary", "evidence": "Integer factoring is the process of determining the prime factors of an integer. It is a central problem in computational number theory and has applications in various fields, including cryptography and algorithm design."}, {"id": "classical algorithm", "name": "classical algorithm", "frequency": 1, "degree": 2, "layer": "secondary", "evidence": "A classical algorithm refers to traditional computational methods that run on classical computers. These algorithms often have limitations in terms of efficiency and speed when compared to quantum algorithms, especially for problems like integer factorization."}, {"id": "complexity", "name": "complexity", "frequency": 1, "degree": 2, "layer": "secondary", "evidence": "Complexity in this context refers to the computational resources required to solve a problem, typically measured in terms of time or space. Understanding complexity is essential for evaluating the efficiency of algorithms and their feasibility for practical applications."}, {"id": "historical significance", "name": "historical significance", "frequency": 1, "degree": 1, "layer": "tertiary", "evidence": "The historical significance of Shor's algorithm lies in its role as the first polynomial-time quantum algorithm proposed for a real-world problem. It marked a pivotal moment in the development of quantum computing and its potential applications."}, {"id": "current technology limitations", "name": "current technology limitations", "frequency": 1, "degree": 4, "layer": "tertiary", "evidence": "Current technology limitations refer to the constraints of existing quantum computers, which are not yet capable of efficiently implementing Shor's algorithm for large integers. This highlights the gap between theoretical advancements and practical applications in quantum computing."}, {"id": "linear-optical network", "name": "linear-optical network", "frequency": 1, "degree": 0, "layer": "priority", "evidence": "A linear-optical network is a system that manipulates light (photons) using linear optical elements like beam splitters and phase shifters. This concept is crucial for implementing boson sampling, as it provides the framework through which photons are processed to achieve quantum computational advantages."}, {"id": "complexity-theoretical conjectures", "name": "complexity-theoretical conjectures", "frequency": 1, "degree": 1, "layer": "priority", "evidence": "Complexity-theoretical conjectures are assumptions made in computational theory regarding the difficulty of certain problems. They are important in the context of boson sampling as they underpin the belief that certain tasks are infeasible for classical computers, thus highlighting the potential advantages of quantum computing."}, {"id": "classical algorithm for simulating boson sampling", "name": "classical algorithm for simulating boson sampling", "frequency": 1, "degree": 1, "layer": "secondary", "evidence": "The classical algorithm for simulating boson sampling provides a benchmark for understanding the computational complexity involved in replicating quantum processes. It illustrates the challenges classical computers face in simulating quantum phenomena, reinforcing the significance of boson sampling in demonstrating quantum advantages."}, {"id": "photons", "name": "photons", "frequency": 1, "degree": 1, "layer": "secondary", "evidence": "Photons are elementary particles of light that are used in boson sampling to represent quantum states. Their manipulation is central to the operation of quantum computing systems, making them a fundamental component in the exploration of quantum algorithms."}, {"id": "gaussian matrices", "name": "gaussian matrices", "frequency": 1, "degree": 0, "layer": "secondary", "evidence": "Gaussian matrices are a type of matrix characterized by their entries being drawn from a Gaussian distribution. The difficulty of calculating their permanent is a key aspect of complexity theory, influencing the understanding of computational limits and the potential for quantum computing to solve certain problems more efficiently."}, {"id": "experimental implementation", "name": "experimental implementation", "frequency": 1, "degree": 1, "layer": "tertiary", "evidence": "Experimental implementation refers to the practical application of theoretical concepts in a controlled environment to test their validity. In the case of boson sampling, such implementations are crucial for demonstrating the feasibility and effectiveness of quantum algorithms in real-world scenarios."}, {"id": "loss and noise in boson sampling", "name": "loss and noise in boson sampling", "frequency": 1, "degree": 2, "layer": "tertiary", "evidence": "Loss and noise are factors that can affect the performance of quantum systems, including boson sampling. Understanding how these elements influence the efficiency of quantum computations is essential for improving quantum algorithms and achieving reliable results."}, {"id": "quantum circuit simulation", "name": "quantum circuit simulation", "frequency": 1, "degree": 0, "layer": "secondary", "evidence": "Quantum circuit simulation involves using classical computers to model the behavior of quantum circuits. This is important for understanding quantum algorithms and testing quantum systems, but it becomes increasingly difficult as the number of qubits increases due to the exponential growth in computational requirements."}, {"id": "sycamore processor", "name": "sycamore processor", "frequency": 1, "degree": 2, "layer": "secondary", "evidence": "The Sycamore processor is a 53-qubit quantum processor developed by Google, designed to perform quantum computations efficiently. Its development represents a significant advancement in quantum hardware, enabling the execution of complex quantum algorithms that were previously infeasible."}, {"id": "bouland, fefferman, nirkhe, and vazirani", "name": "bouland, fefferman, nirkhe, and vazirani", "frequency": 1, "degree": 0, "layer": "tertiary", "evidence": "These researchers contributed to the theoretical understanding of quantum circuit simulation, providing insights into the computational limits of classical algorithms in relation to quantum circuits. Their work is significant as it highlights the challenges faced in simulating quantum systems and the implications for computational complexity theory."}, {"id": "ibm's dispute", "name": "ibm's dispute", "frequency": 1, "degree": 1, "layer": "tertiary", "evidence": "IBM's dispute regarding Google's claim of quantum supremacy emphasizes the ongoing debate within the scientific community about the practical implications of quantum computing versus classical computing. This highlights the importance of rigorous validation and comparison of quantum and classical computational capabilities."}, {"id": "nature article", "name": "nature article", "frequency": 1, "degree": 0, "layer": "tertiary", "evidence": "The Nature article serves as a formal publication of Google's findings on quantum supremacy, providing a peer-reviewed account of their experimental results. This publication is crucial for disseminating knowledge and fostering further research in the field of quantum computing."}, {"id": "quantum computers", "name": "quantum computers", "frequency": 1, "degree": 4, "layer": "priority", "evidence": "Quantum computers are advanced computing systems that leverage the principles of quantum mechanics to process information. They are fundamentally different from classical computers and are particularly sensitive to errors caused by environmental factors, making their reliability a significant concern in their development."}, {"id": "errors", "name": "errors", "frequency": 1, "degree": 3, "layer": "priority", "evidence": "Errors in quantum computing arise from various sources, including decoherence and noise, which can disrupt the delicate quantum states necessary for computation. Understanding and mitigating these errors is crucial for the practical implementation of quantum computers."}, {"id": "threshold theorem", "name": "threshold theorem", "frequency": 1, "degree": 1, "layer": "priority", "evidence": "The threshold theorem is a fundamental principle in quantum computing that asserts that quantum error correction can effectively counteract noise, allowing a quantum computer to function as if it were noiseless, provided that the error rate remains below a certain threshold. This theorem is vital for advancing the reliability of quantum computations."}, {"id": "quantum error-correcting codes", "name": "quantum error-correcting codes", "frequency": 1, "degree": 3, "layer": "secondary", "evidence": "Quantum error-correcting codes are algorithms designed to protect quantum information from errors due to decoherence and noise. They play a crucial role in maintaining the integrity of quantum computations, especially in the context of the threshold theorem."}, {"id": "decoherence", "name": "decoherence", "frequency": 1, "degree": 1, "layer": "secondary", "evidence": "Decoherence refers to the loss of quantum coherence, where quantum states become entangled with their environment, leading to errors in computation. It is a significant challenge in the development of stable quantum computers."}, {"id": "noise", "name": "noise", "frequency": 1, "degree": 1, "layer": "secondary", "evidence": "Noise in quantum computing encompasses various disturbances that can affect the performance and accuracy of quantum operations. Understanding noise is essential for developing effective error correction methods and ensuring reliable quantum computing."}, {"id": "numerical simulations", "name": "numerical simulations", "frequency": 1, "degree": 1, "layer": "tertiary", "evidence": "Numerical simulations are computational methods used to model and predict the behavior of quantum systems under various conditions. They provide insights into error thresholds and help researchers understand the limits of quantum error correction."}, {"id": "skeptics", "name": "skeptics", "frequency": 1, "degree": 1, "layer": "tertiary", "evidence": "Skeptics in the field of quantum computing raise concerns about the practical challenges of scaling quantum systems, particularly regarding noise and error management. Their critiques are important for guiding research priorities and addressing potential pitfalls in quantum technology development."}, {"id": "quantum advantage", "name": "quantum advantage", "frequency": 1, "degree": 4, "layer": "priority", "evidence": "Quantum advantage is a term proposed as an alternative to quantum supremacy, suggesting that a quantum computer has a performance edge over classical computers. However, it implies a relative improvement rather than a complete dominance, which is why some researchers prefer the term quantum supremacy to emphasize the full capabilities of quantum computing."}, {"id": "nature journal", "name": "nature journal", "frequency": 1, "degree": 0, "layer": "tertiary", "evidence": "Nature is a leading scientific journal that publishes significant research and commentary in various fields, including physics. The discussions and articles published in Nature often influence scientific terminology and public understanding of complex concepts like quantum computing."}, {"id": "philip ball", "name": "philip ball", "frequency": 1, "degree": 1, "layer": "tertiary", "evidence": "Philip Ball is a science writer and editor who has contributed to discussions on scientific terminology and its implications. His observations on the shift from 'quantum supremacy' to 'quantum advantage' reflect broader societal concerns about language and its impact on public perception."}, {"id": "theoretical physics", "name": "theoretical physics", "frequency": 1, "degree": 0, "layer": "secondary", "evidence": "Theoretical physics is a branch of physics that uses mathematical models and abstractions to explain and predict natural phenomena. It plays a crucial role in advancing our understanding of complex systems, including quantum mechanics and computing."}], "links": [{"source": "quantum supremacy", "target": "quantum random circuit sampling", "type": "demonstrates capability", "evidence": "Quantum supremacy is often illustrated through specific tasks like quantum random circuit sampling, which showcases the ability of quantum computers to outperform classical computers in certain computations."}, {"source": "quantum computing", "target": "shor's algorithm", "type": "enables algorithms", "evidence": "Quantum computing provides the necessary framework for implementing Shor's algorithm, which is pivotal for factoring large numbers efficiently, a task infeasible for classical computers."}, {"source": "quantum supremacy", "target": "USTC", "type": "achieved by", "evidence": "A group based in the University of Science and Technology of China (USTC) led by Pan Jianwei reached quantum supremacy by implementing gaussian boson sampling."}, {"source": "turing machine", "target": "quantum turing machine", "type": "foundation of computational theory", "evidence": "The quantum Turing machine extends the classical Turing machine model, illustrating how foundational concepts in computational theory evolve to accommodate quantum principles."}, {"source": "numerical simulations", "target": "threshold for error correction", "type": "suggest that", "evidence": "Numerical simulations suggest that that number may be as high as 3%."}, {"source": "quantum computers", "target": "errors", "type": "are susceptible to", "evidence": "Quantum computers are much more susceptible to errors than classical computers due to decoherence and noise."}, {"source": "BQP (bounded-error quantum polynomial time)", "target": "quantum complexity classes", "type": "is a type of", "evidence": "The most useful quantum complexity class is BQP (bounded-error quantum polynomial time), the class of decision problems that can be solved in polynomial time by a universal quantum computer."}, {"source": "quantum computing", "target": "quantum logic gate", "type": "includes", "evidence": "quantum circuits featuring quantum gates drawn from a universal gate set."}, {"source": "neven's law", "target": "quantum supremacy", "type": "suggests", "evidence": "Quanta Magazine suggested that quantum supremacy could happen in 2019, according to Neven's law."}, {"source": "richard feynman", "target": "quantum computing", "type": "argued", "evidence": "Feynman showed that quantum mechanics could not be efficiently simulated on classical devices."}, {"source": "threshold theorem", "target": "quantum error-correcting codes", "type": "states that", "evidence": "The threshold theorem states that a noisy quantum computer can use quantum error-correcting codes to simulate a noiseless quantum computer."}, {"source": "jiuzhang", "target": "gaussian boson sampling", "type": "achieved quantum supremacy by", "evidence": "USTC reached quantum supremacy by implementing gaussian boson sampling on 76 photons."}, {"source": "quantum supremacy", "target": "computational complexity theory", "type": "involves", "evidence": "the computational-complexity-theoretic task of finding a problem that can be solved by that quantum computer"}, {"source": "classical algorithm for simulating boson sampling", "target": "O(n2^{n+mn^{2})}", "type": "has a complexity of", "evidence": "The best proposed classical algorithm for simulating boson sampling runs in time O(n2^{n+mn^{2}) for a system with n photons and m output modes."}, {"source": "quantum supremacy", "target": "quantum computing", "type": "demonstrates capability", "evidence": "Quantum supremacy is a milestone that indicates quantum computing's ability to perform tasks beyond the reach of classical computers, showcasing its potential impact on computational problems."}, {"source": "quantum supremacy", "target": "google", "type": "achieved by", "evidence": "Google claims to have reached quantum supremacy with an array of 54 qubits."}, {"source": "google and ustc research groups", "target": "Random Circuit Sampling", "type": "replicate", "evidence": "the task replicated by the Google and USTC research groups."}, {"source": "shor's algorithm", "target": "prime factorization", "type": "application of quantum computing", "evidence": "Shor's algorithm exemplifies how quantum computing can efficiently solve the prime factorization problem, which is a cornerstone of modern cryptography."}, {"source": "current technology limitations", "target": "quantum advantage", "type": "barrier to", "evidence": "The limitations of current technology, such as noise and loss in quantum systems, hinder the achievement of quantum advantage, where quantum computers outperform classical ones in practical applications."}, {"source": "quantum random circuit sampling", "target": "boson sampling", "type": "alternative approach", "evidence": "Quantum random circuit sampling is another method that can potentially demonstrate quantum supremacy, highlighting the diversity of approaches within quantum computing."}, {"source": "boson sampling", "target": "photons", "type": "requires", "evidence": "The largest experimental implementation of boson sampling to date had 6 modes so could handle up to 6 photons at a time."}, {"source": "historical context", "target": "quantum computing advancements", "type": "foundation for", "evidence": "The historical context of quantum computing, including foundational theories and early experiments, provides essential insights into the evolution and current state of the field."}, {"source": "quantum advantage", "target": "quantum supremacy", "type": "has largely replaced", "evidence": "the term 'quantum advantage' has 'largely replaced' the term 'quantum supremacy'"}, {"source": "boson sampling", "target": "aaronson and arkhipov", "type": "related to quantum supremacy", "evidence": "The concept of boson sampling, proposed by Aaronson and Arkhipov, serves as a benchmark for demonstrating quantum supremacy, linking theoretical advancements with experimental validation."}, {"source": "richard feynman", "target": "quantum computing", "type": "influential figure", "evidence": "Richard Feynman's early insights into simulating quantum systems laid the groundwork for the development of quantum computing, highlighting the historical evolution of the field."}, {"source": "quantum advantage", "target": "thirteen researchers", "type": "is an alternative term suggested by", "evidence": "A controversial commentary article in the journal Nature signed by thirteen researchers asserts that the alternative phrase 'quantum advantage' should be used instead"}, {"source": "rsa cryptosystem", "target": "shor's algorithm", "type": "is believed to be secure under", "evidence": "Namely, it gives a superpolynomial speedup under the reasonable assumption that RSA, a well-established cryptosystem, is secure."}, {"source": "quantum supremacy", "target": "qubits", "type": "requires", "evidence": "around 50 qubits could be enough to demonstrate quantum supremacy."}, {"source": "boson sampling", "target": "sampling problems", "type": "depends on", "evidence": "Boson sampling is a more specific proposal, the classical hardness of which depends upon the intractability of calculating the permanent of a large matrix with complex entries."}, {"source": "quantum phase transition", "target": "quantum computing performance", "type": "phenomenon influencing", "evidence": "Quantum phase transitions can significantly affect the performance of quantum systems, impacting their computational capabilities and the realization of quantum algorithms."}, {"source": "skeptics", "target": "unknown behavior of noise", "type": "point to", "evidence": "Skeptics point to the unknown behavior of noise in scaled-up quantum systems as a potential roadblock for successfully implementing quantum computing."}, {"source": "quantum annealing", "target": "solving optimization problems", "type": "method of", "evidence": "Quantum annealing is a specific approach within quantum computing aimed at solving optimization problems, demonstrating the diverse methodologies within the field."}, {"source": "quantum supremacy", "target": "near-term quantum computers", "type": "can be achieved by", "evidence": "quantum supremacy is that it can be feasibly achieved by near-term quantum computers"}, {"source": "near-term quantum computers", "target": "quantum annealing", "type": "practical application of concepts", "evidence": "Near-term quantum computers often utilize quantum annealing techniques, which are designed to solve optimization problems, showcasing the practical implications of quantum computing theories."}, {"source": "shor's algorithm", "target": "polynomial-time quantum algorithm", "type": "is the first", "evidence": "It was the first polynomial-time quantum algorithm proposed for a real-world problem."}, {"source": "google and ustc research groups", "target": "quantum supremacy demonstration", "type": "collaborative effort in", "evidence": "The collaboration between Google and USTC research groups has been pivotal in advancing the experimental demonstration of quantum supremacy, showcasing the global effort in quantum research."}, {"source": "ibm's dispute", "target": "quantum supremacy", "type": "challenges", "evidence": "IBM disputed this claim, saying that an improved classical algorithm should be able to solve that problem in two and a half days on that same supercomputer."}, {"source": "current technology limitations", "target": "quantum computing", "type": "affect the development of", "evidence": "Current technology limitations impact the scalability and implementation of quantum computing systems."}, {"source": "complexity-theoretical conjectures", "target": "boson sampling", "type": "are assumptions related to", "evidence": "assuming a few complexity-theoretical conjectures (that calculating the permanent of Gaussian matrices is #P-Hard and that the polynomial hierarchy does not collapse)..."}, {"source": "boson sampling", "target": "quantum computing", "type": "related to", "evidence": "The largest universal quantum circuit simulator running on classical supercomputers at the time was able to simulate 48 qubits."}, {"source": "near-term quantum computers", "target": "quantum algorithms", "type": "current technological focus", "evidence": "The development of near-term quantum computers emphasizes the need for quantum algorithms that can be executed on current hardware, bridging theoretical advancements with practical applications."}, {"source": "quantum error-correcting codes", "target": "simulate a noiseless quantum computer", "type": "can be used to", "evidence": "The threshold theorem states that a noisy quantum computer can use quantum error-correcting codes to simulate a noiseless quantum computer."}, {"source": "loss and noise in boson sampling", "target": "experimental implementation", "type": "challenges to implementation", "evidence": "The challenges posed by loss and noise in boson sampling highlight the difficulties faced in the experimental implementation of quantum algorithms, affecting the reliability of results."}, {"source": "aaronson and arkhipov", "target": "boson sampling", "type": "proposed", "evidence": "the boson sampling proposal of Aaronson and Arkhipov"}, {"source": "shor's algorithm", "target": "superpolynomial speedup", "type": "provides", "evidence": "It can also provide a speedup for any problem that reduces to integer factoring."}, {"source": "christopher monroe and david wineland", "target": "quantum logic gate", "type": "demonstrated", "evidence": "published their paper, 'Demonstration of a Fundamental Quantum Logic Gate', marking the first demonstration of a quantum logic gate."}, {"source": "qubits", "target": "resources needed for error correction", "type": "are related to", "evidence": "it is not yet definitively known how the resources needed for error correction will scale with the number of qubits."}, {"source": "grover's algorithm", "target": "quantum algorithm", "type": "is a type of", "evidence": "Grover's algorithm is another significant quantum algorithm for searching unsorted databases."}, {"source": "quantum gates", "target": "circuit model", "type": "are part of", "evidence": "the quantum model consists of classical circuits and the application of unitary operations."}, {"source": "quantum computing", "target": "intractable for classical computers", "type": "addresses problems that are", "evidence": "can solve certain sampling and search problems that... are intractable for classical computers."}, {"source": "paul benioff", "target": "reversible nature of quantum computing", "type": "demonstrated", "evidence": "His paper... was the first to demonstrate that it is possible to show the reversible nature of quantum computing."}, {"source": "quantum supremacy", "target": "john preskill", "type": "is a term coined by", "evidence": "John Preskill, the professor of theoretical physics at the California Institute of Technology who coined the term"}, {"source": "computational complexity theory", "target": "grover's algorithm", "type": "underpins quantum algorithms", "evidence": "Grover's algorithm is a significant result in computational complexity theory, demonstrating how quantum algorithms can provide quadratic speedups over classical counterparts."}, {"source": "quantum supremacy", "target": "programmable quantum computer solving problems", "type": "is defined by", "evidence": "demonstrating that a programmable quantum computer can solve a problem that no classical computer can solve in any feasible amount of time"}, {"source": "quantum supremacy", "target": "quantum advantage", "type": "is rejected in favor of", "evidence": "he specifically rejected the term 'quantum advantage' as it did not fully encapsulate the meaning of his new term"}, {"source": "boson sampling", "target": "quantum computing", "type": "is a method used in", "evidence": "This computing paradigm based upon sending identical photons through a linear-optical network can solve certain sampling and search problems..."}, {"source": "quantum random circuit sampling", "target": "quantum supremacy", "type": "is a proposal for demonstrating", "evidence": "sampling the output of random quantum circuits"}, {"source": "boson sampling", "target": "loss and noise in boson sampling", "type": "is affected by", "evidence": "it has been shown that boson sampling in a system with large enough loss and noise can be simulated efficiently."}, {"source": "quantum complexity theory", "target": "computational complexity theory", "type": "framework for understanding", "evidence": "Quantum complexity theory extends classical computational complexity theory, providing insights into the limits and capabilities of quantum algorithms compared to classical ones."}, {"source": "historical significance", "target": "shor's algorithm", "type": "is associated with", "evidence": "This algorithm is important both practically and historically for quantum computing."}, {"source": "shor's algorithm", "target": "prime factorization", "type": "finds", "evidence": "This algorithm finds the prime factorization of an n-bit integer in O(n^{3}) time."}, {"source": "Nature journal", "target": "philip ball", "type": "published commentary by", "evidence": "Nature's Philip Ball wrote in December 2020"}, {"source": "quantum supremacy", "target": "scientific goal", "type": "is viewed as", "evidence": "researchers view quantum supremacy as primarily a scientific goal"}, {"source": "quantum logic gate", "target": "quantum algorithm", "type": "building block of quantum algorithms", "evidence": "Quantum logic gates are fundamental components that enable the construction of quantum algorithms, illustrating the interdependence of hardware and software in quantum computing."}, {"source": "quantum turing machine", "target": "turing machine", "type": "extends", "evidence": "The quantum Turing machine is a theoretical model that extends the classical Turing machine."}, {"source": "deutsch's algorithm", "target": "clustered quantum computer", "type": "implemented in", "evidence": "the implementation of Deutsch's algorithm in a clustered quantum computer (2007)"}, {"source": "boson sampling", "target": "quantum supremacy", "type": "example of", "evidence": "Boson sampling is often cited as a specific instance where quantum supremacy can be demonstrated, showcasing the capabilities of quantum systems over classical counterparts."}, {"source": "integer factoring", "target": "shor's algorithm", "type": "is a problem that", "evidence": "It can also provide a speedup for any problem that reduces to integer factoring."}, {"source": "boson sampling", "target": "quantum supremacy", "type": "is a proposal for demonstrating", "evidence": "Examples of proposals to demonstrate quantum supremacy include the boson sampling proposal of Aaronson and Arkhipov"}, {"source": "D-Wave Systems", "target": "quantum computer", "type": "first commercial quantum computer", "evidence": "D-Wave Systems became the first company to sell a quantum computer commercially."}, {"source": "current technology limitations", "target": "quantum supremacy", "type": "affects", "evidence": "The largest universal quantum circuit simulator running on classical supercomputers at the time was able to simulate 48 qubits."}, {"source": "john preskill", "target": "quantum supremacy", "type": "advocate for quantum supremacy", "evidence": "John Preskill's advocacy for quantum supremacy emphasizes the potential of quantum computers to solve problems beyond the reach of classical computing, linking theoretical discussions with future technological aspirations."}, {"source": "classical algorithm", "target": "shor's algorithm", "type": "requires more time than", "evidence": "the best known classical algorithm requires 2^{O(n^{1/3})} time."}, {"source": "quantum supremacy", "target": "boson sampling", "type": "can be demonstrated by", "evidence": "The algorithm leads to an estimate of 50 photons required to demonstrate quantum supremacy with boson sampling."}, {"source": "noise", "target": "errors", "type": "contributes to", "evidence": "Quantum computers are much more susceptible to errors than classical computers due to decoherence and noise."}, {"source": "richard feynman", "target": "quantum computing", "type": "contributed to the concept of", "evidence": "the concept dates to Richard Feynman's 1981 proposals of quantum computing"}, {"source": "jonathan a. jones and michele mosca", "target": "quantum algorithm", "type": "published", "evidence": "published 'Implementation of a Quantum Algorithm to Solve Deutsch's Problem on a Nuclear Magnetic Resonance Quantum Computer', marking the first demonstration of a quantum algorithm."}, {"source": "quantum annealing", "target": "D-Wave Systems", "type": "used in", "evidence": "D-Wave Systems reported on an experiment using a quantum annealing based processor."}, {"source": "shor's algorithm", "target": "quantum algorithm", "type": "is a type of", "evidence": "Shor's algorithm is a well-known quantum algorithm for factoring."}, {"source": "shor's theorem", "target": "2001", "type": "demonstrated in", "evidence": "the demonstration of Shor's theorem (2001)"}, {"source": "quantum error-correcting codes", "target": "errors in quantum computing", "type": "solution to", "evidence": "Quantum error-correcting codes are essential for mitigating errors and decoherence in quantum systems, which are critical challenges in realizing practical quantum computers."}, {"source": "shor's algorithm", "target": "prime factorization", "type": "is related to", "evidence": "Shor's algorithm is known for its efficiency in prime factorization."}, {"source": "david deutsch", "target": "quantum algorithm", "type": "designed", "evidence": "designed an algorithm created to run on a quantum computer."}, {"source": "david deutsch", "target": "quantum turing machine", "type": "produced", "evidence": "David Deutsch produced a description for a quantum Turing machine."}, {"source": "classical computers", "target": "quantum computers", "type": "comparison basis", "evidence": "Classical computers serve as a benchmark for evaluating the performance and capabilities of quantum computers, particularly in terms of speed and efficiency in solving complex problems."}, {"source": "yuri manin", "target": "quantum computing", "type": "contributed to the concept of", "evidence": "the concept dates to Yuri Manin's 1980 proposals of quantum computing"}, {"source": "circuit model", "target": "quantum complexity classes", "type": "describes", "evidence": "Circuit models are useful in describing quantum complexity classes."}, {"source": "google and ustc research groups", "target": "quantum supremacy", "type": "collaborative efforts", "evidence": "The collaboration between Google and USTC research groups represents a significant effort in the pursuit of demonstrating quantum supremacy through innovative quantum computing techniques."}, {"source": "historical context", "target": "quantum computing", "type": "foundation for current research", "evidence": "Understanding the historical context of quantum computing provides insights into its evolution and the foundational theories that have shaped current research and technological advancements."}, {"source": "quantum computing", "target": "quantum algorithm", "type": "related to", "evidence": "Researchers have since developed better algorithms for the sampling problem used to claim quantum supremacy."}, {"source": "quantum supremacy", "target": "sycamore processor", "type": "demonstrated by", "evidence": "Google had announced its intention to demonstrate quantum supremacy by the end of 2017 by constructing and running a 49-qubit chip... On October 23, 2019, Google published the results of this quantum supremacy experiment in the Nature article, 'Quantum Supremacy Using a Programmable Superconducting Processor' in which they developed a new 53-qubit processor, named 'Sycamore'."}, {"source": "quantum phase transition", "target": "quantum annealing", "type": "phenomenon in quantum systems", "evidence": "Quantum phase transitions are critical to understanding the behavior of quantum systems during quantum annealing, linking theoretical physics with practical applications in quantum computing."}, {"source": "paul benioff", "target": "quantum computing", "type": "proposed", "evidence": "Paul Benioff used Turing's paper to propose the theoretical feasibility of Quantum Computing."}, {"source": "lov grover", "target": "grover's algorithm", "type": "published", "evidence": "published his algorithm, Grover's Algorithm, in his paper, 'A fast quantum mechanical algorithm for database search'."}, {"source": "classical computers", "target": "quantum computers", "type": "are compared to", "evidence": "no classical computer can solve in any feasible amount of time"}, {"source": "sampling problems", "target": "decision problems", "type": "contrast with", "evidence": "Contrary to decision problems that require yes or no answers, sampling problems ask for samples from probability distributions."}, {"source": "quantum supremacy", "target": "quantum computers", "type": "is proposed to describe", "evidence": "the moment that a quantum computer gains the ability to perform a task that a classical computer never could"}, {"source": "complexity arguments", "target": "sampling problems", "type": "concern", "evidence": "The difficulty of proving what cannot be done with classical computing is a common problem in definitively demonstrating quantum supremacy."}, {"source": "unknown behavior of noise", "target": "demonstrating quantum supremacy", "type": "is a potential roadblock for", "evidence": "Skeptics point to the unknown behavior of noise in scaled-up quantum systems as a potential roadblock for successfully implementing quantum computing and demonstrating quantum supremacy."}, {"source": "peter shor", "target": "shor's algorithm", "type": "formulated", "evidence": "Peter Shor formulated Shor's algorithm, streamlining a method for factoring integers in polynomial time."}, {"source": "quantum supremacy", "target": "classical computers", "type": "implies complete ascendancy over", "evidence": "the word 'supremacy' better conveys complete ascendancy over any classical computer"}, {"source": "quantum complexity theory", "target": "quantum algorithms", "type": "framework for understanding", "evidence": "Quantum complexity theory provides the theoretical foundation for analyzing the efficiency and capabilities of quantum algorithms, influencing the development of new quantum computational methods."}, {"source": "rsa cryptosystem", "target": "integer factoring", "type": "is based on the difficulty of", "evidence": "The RSA cryptosystem relies on the difficulty of integer factoring."}, {"source": "quantum gates", "target": "quantum circuits", "type": "building blocks", "evidence": "Quantum gates are fundamental components of quantum circuits, which are essential for implementing quantum algorithms and achieving desired computational outcomes."}, {"source": "quantum complexity theory", "target": "classical computational complexity theory", "type": "extends", "evidence": "As an extension of classical computational complexity theory, quantum complexity theory considers what a theoretical universal quantum computer could accomplish."}, {"source": "complexity", "target": "quantum supremacy", "type": "impacted by", "evidence": "Bouland, Fefferman, Nirkhe and Vazirani gave, in 2018, theoretical evidence that efficiently simulating a random quantum circuit would require a collapse of the computational polynomial hierarchy."}, {"source": "decoherence", "target": "errors", "type": "contributes to", "evidence": "Quantum computers are much more susceptible to errors than classical computers due to decoherence and noise."}, {"source": "quantum supremacy", "target": "quantum computing", "type": "demonstrates", "evidence": "Quantum supremacy is a milestone that signifies the point at which quantum computers can perform tasks that classical computers cannot, highlighting the transformative potential of quantum computing."}, {"source": "shor's algorithm", "target": "quantum computing", "type": "application of", "evidence": "Shor's algorithm exemplifies how quantum computing can solve problems, such as integer factoring, exponentially faster than classical algorithms, thus illustrating the practical implications of quantum computing."}, {"source": "boson sampling", "target": "quantum supremacy", "type": "example of quantum advantage", "evidence": "Boson sampling serves as a specific instance where quantum supremacy can be demonstrated, as it is a problem that classical computers struggle to solve efficiently compared to quantum systems."}, {"source": "john preskill", "target": "quantum supremacy", "type": "coined the term", "evidence": "The term was coined by John Preskill in 2011"}, {"source": "classical algorithm", "target": "quantum supremacy", "type": "compared to", "evidence": "Google claims that their machine performed the target computation in 200 seconds, and estimated that their classical algorithm would take 10,000 years in the world's fastest supercomputer to solve the same problem."}, {"source": "alan turing", "target": "turing machine", "type": "developed", "evidence": "Turing's paper described what he called a 'universal computing machine', which later became known as a Turing machine."}, {"source": "shor's algorithm", "target": "quantum computing", "type": "is important for", "evidence": "This algorithm is important both practically and historically for quantum computing."}, {"source": "current technology limitations", "target": "implementation of shor's algorithm", "type": "affects", "evidence": "However, implementing Shor's algorithm for large numbers is infeasible with current technology."}, {"source": "complexity", "target": "integer factoring", "type": "has an upper bound for", "evidence": "the best upper bound for the complexity of this problem is O(2^{n/3+o(1)})"}, {"source": "superpolynomial speedup", "target": "quantum computing", "type": "is a goal of", "evidence": "Quantum computing aims to achieve superpolynomial speedup over classical algorithms."}, {"source": "quantum phase transition", "target": "quantum annealing", "type": "related to", "evidence": "the simulation of the non-equilibrium dynamics of a magnetic spin system quenched through a quantum phase transition."}, {"source": "quantum random circuit sampling", "target": "quantum supremacy", "type": "related to", "evidence": "The scheme discussed was a variant of a quantum random sampling scheme in which qubits undergo random quantum circuits."}, {"source": "sycamore processor", "target": "fast, high-fidelity quantum logic gates", "type": "capable of", "evidence": "Google claims that their machine performed the target computation in 200 seconds."}], "expandedNodes": []};

            document.addEventListener('DOMContentLoaded', function() {
                // Set up variables
                let expandedNodes = new Set(networkData.expandedNodes || []);
                let pinnedNodes = new Set(); // Track pinned/fixed nodes
                
                let currentSimulation = null;
                let currentNodes = [];
                
                let focusedNodeId = null;

                const width = 800;
                const height = 600;
                const centerX = width / 2;
                const centerY = height / 2;

                // Color scheme - shades of green from lightest to darkest
                const colorScheme = [
                    "#D1EDE8", "#ABD9D1", "#97C0DB", "#6596B5", "#9C82DE", "#9575CD"
                ];

                // Set up SVG and tooltips
                const svg = d3.select("#concept-map");
                const tooltip = d3.select("#tooltip");
                const evidenceTooltip = d3.select("#evidence-tooltip");

                // Create a group for zooming
                const g = svg.append("g");

                // Set up zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.5, 5])
                    .on("zoom", function(event) {
                        g.attr("transform", event.transform);
                    });

                svg.call(zoom);

                // Ensure nodes have string IDs and links reference those IDs
                networkData.nodes.forEach(node => {
                    node.id = String(node.id);
                });

                networkData.links.forEach(link => {
                    link.source = String(link.source);
                    link.target = String(link.target);
                });

                // Validate links - only keep links where both source and target nodes exist
                const validNodeIds = new Set(networkData.nodes.map(node => node.id));
                networkData.links = networkData.links.filter(link => 
                    validNodeIds.has(link.source) && validNodeIds.has(link.target)
                );

                // Function to calculate importance score
                function calculateImportanceScore(node) {
                    const frequencyWeight = 0.6;
                    const maxFrequency = Math.max(...networkData.nodes.map(n => n.frequency || 0), 1);
                    const maxDegree = Math.max(...networkData.nodes.map(n => n.degree || 0), 1);
                    const normalizedFrequency = (node.frequency || 0) / maxFrequency;
                    const normalizedDegree = (node.degree || 0) / maxDegree;
                    return (normalizedFrequency * frequencyWeight) + (normalizedDegree * (1 - frequencyWeight));
                }

                // Find the most important concept to place at the center
                function findCentralNode(nodes) {
                    return nodes.reduce((max, node) => {
                        const score = calculateImportanceScore(node);
                        return (score > calculateImportanceScore(max)) ? node : max;
                    }, nodes[0]);
                }

                // Function to get node size based on importance
                function getNodeSize(node) {
                    const score = calculateImportanceScore(node);
                    return 10 + (score * 30);  // Min 10, max 40
                }

                // Function to get node color based on layer
                function getNodeColor(node) {
                    let baseIntensity;
                    switch(node.layer) {
                        case 'priority':
                            baseIntensity = 5; // Darkest shade
                            break;
                        case 'secondary':
                            baseIntensity = 2; // Medium shade
                            break;
                        case 'tertiary':
                        default:
                            baseIntensity = 0; // Lightest shade
                    }

                    const score = calculateImportanceScore(node);
                    const intensityVariation = Math.min(Math.floor(score * 2), 1);
                    const colorIndex = Math.min(Math.max(baseIntensity - intensityVariation, 0), colorScheme.length - 1);

                    return colorScheme[colorIndex];
                }

                // Function to get visible data based on expanded nodes
                function getVisibleData() {
                    console.log("Getting visible data with expanded nodes:", Array.from(expandedNodes));
                    
                    // Priority nodes are always visible
                    const visibleNodeIds = new Set(
                        networkData.nodes
                            .filter(node => node.layer === "priority" || expandedNodes.has(node.id))
                            .map(node => node.id)
                    );
                    
                    console.log(`Initial visible nodes (priority + expanded): ${visibleNodeIds.size}`);
                    
                    // Keep track of how many nodes we add in this expansion pass
                    let nodesAdded = 0;
                    
                    // Find all nodes connected to expanded nodes
                    expandedNodes.forEach(expandedId => {
                        networkData.links.forEach(link => {
                            let sourceId, targetId;
                            
                            // Handle both string and object formats
                            if (typeof link.source === 'object') {
                                sourceId = link.source.id;
                            } else {
                                sourceId = String(link.source);
                            }
                            
                            if (typeof link.target === 'object') {
                                targetId = link.target.id;
                            } else {
                                targetId = String(link.target);
                            }
                            
                            if (sourceId === expandedId && !visibleNodeIds.has(targetId)) {
                                visibleNodeIds.add(targetId);
                                nodesAdded++;
                            }
                            
                            if (targetId === expandedId && !visibleNodeIds.has(sourceId)) {
                                visibleNodeIds.add(sourceId);
                                nodesAdded++;
                            }
                        });
                    });
                    
                    console.log(`Added ${nodesAdded} connected nodes to visible set`);
                    console.log(`Total visible nodes: ${visibleNodeIds.size}`);
                    
                    // Get visible nodes
                    const visibleNodes = networkData.nodes.filter(node => 
                        visibleNodeIds.has(node.id)
                    );
                    
                    // Get visible links
                    const visibleLinks = networkData.links.filter(link => {
                        let sourceId, targetId;
                        
                        // Handle both string and object formats
                        if (typeof link.source === 'object') {
                            sourceId = link.source.id;
                        } else {
                            sourceId = String(link.source);
                        }
                        
                        if (typeof link.target === 'object') {
                            targetId = link.target.id;
                        } else {
                            targetId = String(link.target);
                        }
                        
                        return visibleNodeIds.has(sourceId) && visibleNodeIds.has(targetId);
                    });
                    
                    console.log(`Visible nodes: ${visibleNodes.length}, Visible links: ${visibleLinks.length}`);
                    
                    return { nodes: visibleNodes, links: visibleLinks };
                }

                // Function to find nodes with hidden connections
                function getAllNodesWithHiddenConnections() {
                    // Get all nodes
                    const allNodeIds = new Set(networkData.nodes.map(n => n.id));
                    
                    // Get currently visible nodes
                    const visibleData = getVisibleData();
                    const visibleNodeIds = new Set(visibleData.nodes.map(n => n.id));
                    
                    // Build a map of all connections
                    const allConnections = new Map();
                    
                    // Initialize map with all nodes
                    allNodeIds.forEach(nodeId => {
                        allConnections.set(nodeId, []);
                    });
                    
                    // Add all connections
                    networkData.links.forEach(link => {
                        const sourceId = typeof link.source === 'object' ? link.source.id : String(link.source);
                        const targetId = typeof link.target === 'object' ? link.target.id : String(link.target);
                        
                        if (allConnections.has(sourceId)) {
                            allConnections.get(sourceId).push(targetId);
                        }
                        
                        if (allConnections.has(targetId)) {
                            allConnections.get(targetId).push(sourceId);
                        }
                    });
                    
                    // Find all nodes that have hidden connections
                    const nodesWithHidden = new Set();
                    
                    // Check each visible node
                    visibleNodeIds.forEach(nodeId => {
                        const connections = allConnections.get(nodeId) || [];

                        // If any connection is to a non-visible node, this node has hidden connections
                        if (connections.some(connId => !visibleNodeIds.has(connId))) {
                            nodesWithHidden.add(nodeId);
                        }
                    });

                    // Print debug info
                    console.log(`Found ${nodesWithHidden.size} nodes with hidden connections`);
                    console.log("Nodes with hidden connections:", Array.from(nodesWithHidden));

                    return nodesWithHidden;
                }

                // Function to assign initial positions in concentric circles
                function assignInitialPositions(nodes, centralNodeId) {
                    // Group nodes by layer
                    const layerGroups = {"priority": [], "secondary": [], "tertiary": []};
                    
                    // First pass - identify layers and pinned nodes
                    nodes.forEach(node => {
                        if (pinnedNodes.has(node.id)) {
                            console.log("Preserving position for pinned node:", node.id);
                            // Make sure fx and fy are set from existing position
                            node.fx = node.x;
                            node.fy = node.y;
                            return; // Skip further positioning for pinned nodes
                        }
                        
                        if (node.id === centralNodeId) {
                            // Central node stays at center
                            node.x = centerX;
                            node.y = centerY;
                            node.fx = centerX; // Fix position
                            node.fy = centerY; // Fix position
                            node.isCenter = true;
                        } else {
                            // Group other nodes by layer
                            const layer = node.layer || "tertiary";
                            layerGroups[layer].push(node);
                            // Clear any fixed positions for non-pinned nodes
                            if (!pinnedNodes.has(node.id)) {
                                node.fx = null;
                                node.fy = null;
                            }
                            node.isCenter = false;
                        }
                    });
                    
                    // Position nodes in evenly distributed concentric circles by layer
                    positionNodesInCircle(layerGroups["priority"], 120);
                    positionNodesInCircle(layerGroups["secondary"], 240);
                    positionNodesInCircle(layerGroups["tertiary"], 360);
                }

                // Helper function to position nodes in a circle
                function positionNodesInCircle(nodes, radius) {
                    const count = nodes.length;
                    if (count === 0) return;
                    
                    // Evenly distribute nodes around the circle
                    const angleStep = (2 * Math.PI) / count;
                    
                    // Use a randomized offset to avoid bias to any particular direction
                    const startAngle = Math.random() * 2 * Math.PI;
                    
                    nodes.forEach((node, i) => {
                        // Calculate angle with random offset to avoid clustering
                        const angle = startAngle + i * angleStep;
                        
                        // Position node on the circle
                        node.x = centerX + radius * Math.cos(angle);
                        node.y = centerY + radius * Math.sin(angle);
                    });
                }

                // Function to update the visualization
                function updateVisualization() {
                    // Get current data
                    const { nodes, links } = getVisibleData();
                    const nodesWithHidden = getAllNodesWithHiddenConnections();
                    
                    currentNodes = nodes;
                    currentLinks = links;

                    // Find central node
                    const centralNode = findCentralNode(nodes);

                    // Clear previous elements
                    g.selectAll("*").remove();

                    // Create a node ID lookup for the simulation
                    const nodeById = new Map(nodes.map(node => [node.id, node]));
                    
                    nodes.forEach(node => {
                        if (pinnedNodes.has(node.id)) {
                            // If this node is pinned, ensure it has fixed coordinates
                            const pinnedNode = nodeById.get(node.id);
                            if (pinnedNode) {
                                node.fx = pinnedNode.x || node.x;
                                node.fy = pinnedNode.y || node.y;
                            }
                        }
                    });

                    // Assign initial positions
                    assignInitialPositions(nodes, centralNode.id);

                    // Set up the simulation with proper node references and forces
                     const simulation = d3.forceSimulation(nodes)
                        .force("link", d3.forceLink()
                            .id(d => d.id)
                            .links(links.map(link => ({
                                source: nodeById.get(String(link.source)) || String(link.source),
                                target: nodeById.get(String(link.target)) || String(link.target),
                                type: link.type,
                                evidence: link.evidence
                            })))
                            .distance(d => {
                                // Adjust distance based on layer and node size
                                const source = typeof d.source === 'object' ? d.source : nodeById.get(String(d.source));
                                const target = typeof d.target === 'object' ? d.target : nodeById.get(String(d.target));
                        
                                if (!source || !target) return 120;
                        
                                // Get sizes of source and target nodes
                                const sourceSize = getNodeSize(source);
                                const targetSize = getNodeSize(target);
                                
                                // Base distance on node sizes + a minimum distance
                                const baseDistance = sourceSize + targetSize + 30;
                                
                                // Layer-based adjustments
                                if (source.layer === "priority" && target.layer === "priority") {
                                    // Priority-to-priority connections are slightly closer
                                    return baseDistance * 1.2;
                                } else if (source.layer === "priority" || target.layer === "priority") {
                                    // Priority-to-other connections at medium distance
                                    return baseDistance * 1.5;
                                }
                                
                                // Other connections have more space
                                return baseDistance * 2.0;
                            })
                            .strength(0.3))
                        .force("charge", d3.forceManyBody().strength(d => {
                            // Stronger repulsion for larger nodes
                            return d.isCenter ? -500 : -300;
                        }))
                        .force("center", d3.forceCenter(centerX, centerY).strength(0.2)) // Stronger centering force
                        .force("collide", d3.forceCollide().radius(d => getNodeSize(d) + 10))
                        .force("x", d3.forceX(centerX).strength(d => {
                            // Stronger x-centering for all nodes
                            if (d.isCenter) return 1.0;
                            if (d.layer === "priority") return 0.15; // Increased from 0.1
                            if (d.layer === "secondary") return 0.1; // Increased from 0.05
                            return 0.05; // Increased from 0.01
                        }))
                        .force("y", d3.forceY(centerY).strength(d => {
                            // Stronger y-centering for all nodes
                            if (d.isCenter) return 1.0;
                            if (d.layer === "priority") return 0.15;
                            if (d.layer === "secondary") return 0.1;
                            return 0.05;
                        }))
                        .force("radial", d3.forceRadial(d => {
                            // Target radius based on layer
                            if (d.layer === "priority") return 120;
                            if (d.layer === "secondary") return 240;
                            return 360; // tertiary
                        }, centerX, centerY).strength(0.15))
                        .force("link-repulsion", d3.forceManyBody()
                            .strength(-10)
                            .distanceMax(150)
                            .distanceMin(25))
                        .alphaDecay(0.02);
                    
                    currentSimulation = simulation;

                    // Create links with hover effects
                    const link = g.selectAll(".link")
                        .data(links)
                        .join("path")
                        .attr("class", "link")
                        .attr("stroke", function(d) {
                            // Get the target node
                            const target = typeof d.target === 'object' ? d.target : nodeById.get(String(d.target));
                            
                            if (!target) return "#BDBDBD"; // Default gray
                            
                            // Color based on target's layer
                            switch(target.layer) {
                                case "priority":
                                    return "#B39DDB"; // Purple for priority
                                case "secondary":
                                    return "#90CAF9"; // Blue for secondary
                                case "tertiary":
                                    return "#B2DFDB"; // Light blue/green for tertiary
                                default:
                                    return "#BDBDBD"; // Default gray
                            }
                        })
                        .attr("stroke-opacity", 0.6)
                        .attr("stroke-width", function(d) {
                            const sourceNode = nodes.find(n => n.id === String(d.source));
                            const targetNode = nodes.find(n => n.id === String(d.target));
                            return (sourceNode?.layer === "priority" && targetNode?.layer === "priority") ? 3 : 1.5;
                        })
                        .attr("fill", "none")
                        .on("mouseover", function(event, d) {
                            // Highlight the line on hover
                            const currentColor = d3.select(this).attr("stroke");
                            const sourceNode = typeof d.source === 'object' ? d.source : nodeById.get(String(d.source));
                            const targetNode = typeof d.target === 'object' ? d.target : nodeById.get(String(d.target));
                        
                            d3.select(this)
                                .attr("stroke-opacity", 1)
                                .attr("stroke-width", function() {
                                    return parseFloat(d3.select(this).attr("stroke-width")) + 1;
                                })
                                .attr("stroke", function() {
                                    // Darken the current color for hover effect
                                    const target = typeof d.target === 'object' ? d.target : nodeById.get(String(d.target));
                                    
                                    if (!target) return "#999";
                                    
                                    switch(target.layer) {
                                        case "priority":
                                            return "#9575CD"; // Slightly darker purple
                                        case "secondary":
                                            return "#64B5F6"; // Slightly darker blue
                                        case "tertiary":
                                            return "#80CBC4"; // Slightly darker teal
                                        default:
                                            return "#999"; // Darker gray
                                    }
                                });
                            
                            if (sourceNode && targetNode) {
                                evidenceTooltip
                                    .style("display", "block")
                                    .style("left", event.pageX + 10 + "px")
                                    .style("top", event.pageY - 10 + "px")
                                    .html(`
                                        <strong>${sourceNode.name || sourceNode.id}</strong>
                                        <span style="margin: 0 5px;"></span>
                                        <strong>${d.type || "relates to"}</strong>
                                        <span style="margin: 0 5px;"></span>
                                        <strong>${targetNode.name || targetNode.id}</strong>
                                        <hr style="margin: 8px 0;">
                                        <div>${d.evidence || "No evidence available"}</div>
                                    `);
                            };
                        })
                        .on("mouseout", function() {
                            // Restore original line style                            
                            d3.select(this)
                                    .attr("stroke-opacity", 0.6)
                                    .attr("stroke-width", function(d) {
                                        const target = typeof d.target === 'object' ? d.target : nodeById.get(String(d.target));
                                        
                                        if (target && target.layer === "priority") return 2;
                                        if (target && target.layer === "secondary") return 1.8;
                                        return 1.5;
                                    })
                                    .attr("stroke", function(d) {
                                        // Restore original color
                                        const target = typeof d.target === 'object' ? d.target : nodeById.get(String(d.target));
                                        
                                        if (!target) return "#BDBDBD";
                                        
                                        switch(target.layer) {
                                            case "priority":
                                                return "#B39DDB"; // Light purple
                                            case "secondary":
                                                return "#90CAF9"; // Light blue
                                            case "tertiary":
                                                return "#B2DFDB"; // Light teal
                                            default:
                                                return "#BDBDBD";
                                        }
                                    });

                            // Hide the evidence tooltip
                            evidenceTooltip.style("display", "none");
                        });

                    // Create node groups
                    const node = g.selectAll(".node")
                        .data(nodes)
                        .join("g")
                        .attr("class", function(d) {
                            return "node node--" + (d.layer || "tertiary") + 
                                   (expandedNodes.has(d.id) ? " node--expanded" : "") +
                                   (d.isCenter ? " center-node" : "");
                        });
                    
                    node
                        // Left-click for expanding/collapsing hidden connections
                        // Update the node click handler
                        .on("click", function(event, d) {
                            event.stopPropagation();
                            
                            // Store current positions of all nodes
                            const nodePositions = new Map();
                            currentNodes.forEach(node => {
                                nodePositions.set(node.id, {x: node.x, y: node.y});
                            });
                        
                            if (nodesWithHidden.has(d.id)) {
                                // First apply focus immediately regardless of expansion state
                                applyFocus(d.id);
                                focusedNodeId = d.id;
                                
                                // Toggle expansion state
                                if (expandedNodes.has(d.id)) {
                                    // COLLAPSING - The node is already expanded, so collapse it
                                    expandedNodes.delete(d.id);
                                    pinnedNodes.delete(d.id);
                                    d.fx = null;
                                    d.fy = null;
                                    d3.select(this).classed("node--pinned", false);
                                    
                                    // Update visualization (removes hidden connections)
                                    updateVisualization();
                                    
                                    // After visualization update, reapply focus to remaining nodes
                                    setTimeout(() => {
                                        if (focusedNodeId) {
                                            applyFocus(focusedNodeId);
                                        }
                                    }, 50);
                                } else {
                                    // EXPANDING - Node isn't expanded yet, so expand it
                                    expandedNodes.add(d.id);
                                    pinnedNodes.add(d.id);
                                    d.fx = d.x;
                                    d.fy = d.y;
                                    d3.select(this).classed("node--pinned", true);
                                    
                                    // Update visualization to show hidden connections
                                    updateVisualization();
                                    
                                    // After updating, fix positions and reapply focus
                                    setTimeout(() => {
                                        g.selectAll(".node").each(function(node) {
                                            const oldPos = nodePositions.get(node.id);
                                            if (oldPos) {
                                                // Fix this node at its previous position temporarily
                                                node.fx = oldPos.x;
                                                node.fy = oldPos.y;
                                            }
                                            
                                            // Keep expanded nodes pinned
                                            if (pinnedNodes.has(node.id)) {
                                                node.fx = node.x;
                                                node.fy = node.y;
                                            }
                                        });
                                        
                                        // Run simulation to position new nodes
                                        currentSimulation.alpha(0.3).restart();
                                        
                                        // Release non-pinned nodes after a delay
                                        setTimeout(() => {
                                            g.selectAll(".node").each(function(node) {
                                                if (!pinnedNodes.has(node.id) && !node.isCenter) {
                                                    node.fx = null;
                                                    node.fy = null;
                                                }
                                            });
                                            
                                            currentSimulation.alpha(0.05).restart();
                                            
                                            // Reapply focus to include new connections
                                            if (focusedNodeId) {
                                                applyFocus(focusedNodeId);
                                            }
                                        }, 1500);
                                    }, 50);
                                }
                            
                                sendMessageToStreamlit({
                                    expandedNodes: Array.from(expandedNodes)
                                });
                            }
                            // Case 2: Node doesn't have hidden connections - just toggle focus
                            else {
                                // If already focused, unfocus
                                if (focusedNodeId === d.id) {
                                    focusedNodeId = null;
                                    resetFocus();
                                } 
                                // Otherwise set focus to this node
                                else {
                                    focusedNodeId = d.id;
                                    // Pin the node temporarily while focused
                                    if (d && !d.isCenter) {
                                        d.fx = d.x;
                                        d.fy = d.y;
                                    }
                                    // Apply visual focus immediately
                                    applyFocus(d.id);
                                }
                            }
                        
                            // Try to sync with Streamlit if needed
                            sendMessageToStreamlit({
                                expandedNodes: Array.from(expandedNodes)
                            });
                        })
                        // Right-click (contextmenu) for concept explanation
                        .on("contextmenu", function(event, d) {
                            // Prevent the default context menu
                            event.preventDefault();
                            
                            // Get the evidence for this concept
                            const nodeData = networkData.nodes.find(n => n.id === d.id);
                            const evidence = nodeData.evidence || "No explanation available for this concept.";
                                                        
                            // Create or update the explanation panel
                            if (!d3.select("#explanation-panel").size()) {
                                d3.select("body").append("div")
                                    .attr("id", "explanation-panel")
                                    .style("position", "absolute")
                                    .style("padding", "15px")
                                    .style("background", "white")
                                    .style("border", "1px solid #ccc")
                                    .style("border-radius", "8px")
                                    .style("box-shadow", "0 2px 10px rgba(0,0,0,0.2)")
                                    .style("max-width", "300px")
                                    .style("z-index", "1000")
                                    .style("font-size", "14px")
                                    .style("line-height", "1.4");
                                    
                                // Add close button
                                d3.select("#explanation-panel")
                                    .append("button")
                                    .attr("class", "close-explanation")
                                    .style("position", "absolute")
                                    .style("top", "5px")
                                    .style("right", "5px")
                                    .style("background", "none")
                                    .style("border", "none")
                                    .style("font-size", "16px")
                                    .style("cursor", "pointer")
                                    .style("color", "#666")
                                    .html("&times;")
                                    .on("click", function() {
                                        d3.select("#explanation-panel").style("display", "none");
                                    });
                            }
                            
                            // Update and position the explanation panel
                            d3.select("#explanation-panel")
                                .style("display", "block")
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 10) + "px")
                                .html(`
                                    <button class="close-explanation" style="position:absolute;top:5px;right:5px;background:none;border:none;font-size:16px;cursor:pointer;color:#666;">&times;</button>
                                    <div style="margin-top: 5px;">
                                        <h3 style="margin-top:0;margin-bottom:10px;color:#2196F3;">${d.name || d.id}</h3>
                                        <p>${evidence}</p>
                                        <span style="display:block;margin-top:8px;font-style:italic;color:#666;font-size:12px;">Layer: ${d.layer || "unknown"}</span>
                                    </div>
                                `);
                                
                            // Handle close button click
                            d3.select(".close-explanation").on("click", function() {
                                d3.select("#explanation-panel").style("display", "none");
                            });
                                
                            // Visual feedback for right-click
                            d3.select(this).select("circle")
                                .transition()
                                .duration(200)
                                .attr("r", function(d) { return getNodeSize(d) * 1.2; })
                                .transition()
                                .duration(200)
                                .attr("r", function(d) { return getNodeSize(d); });
                        })
                        .on("mouseover", function(event, d) {
                            // Show basic node info on hover with updated instructions
                            tooltip
                                .style("display", "block")
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 10) + "px")
                                .html("<strong>" + (d.name || d.id) + "</strong><br>" +
                                      "<em>Level: " + (d.layer || "unknown") + "</em><br>" +
                                      "<em>Frequency: " + (d.frequency || 0) + "</em><br>" +
                                      "<em>Connections: " + (d.degree || 0) + "</em>" +
                                      (nodesWithHidden.has(d.id)
                                          ? "<br><span style='color:#FF8A65'><em>Click to expand hidden connections" + 
                                            (pinnedNodes.has(d.id) ? " (pinned)" : "") + "</em></span>"
                                          : "<br><span style='color:#2196F3'><em>Click to focus on this node's connections</em></span>") +
                                      "<br><span style='color:#2196F3'><em>Right-click for explanation</em></span>");
                        })
                        .on("mouseout", function() {
                            tooltip.style("display", "none");
                        })
                        .call(d3.drag()
                            .on("start", dragstarted)
                            .on("drag", dragged)
                            .on("end", dragended));

                    // Add circles to nodes with filled colors
                    const nodeCircles = node.append("circle")
                        .attr("r", function(d) { return getNodeSize(d); })
                        .attr("fill", function(d) { return getNodeColor(d); })  // Use color for fill
                        .attr("stroke", "#7E57C2");  // White stroke by default

                    // Add pulse animation to nodes with hidden connections
                    node.filter(function(d) { return nodesWithHidden.has(d.id); })
                        .append("circle")
                        .attr("r", function(d) { return getNodeSize(d) + 1; })
                        .attr("fill", "none")
                        .style("stroke", "#FF8A65")
                        .style("stroke-width", "2px")
                        .attr("class", "pulse-ring")
                        // Crucially, store the node ID as a data attribute
                        .attr("data-node-id", function(d) { return d.id; })
                        .call(function(selection) {
                            // Define the pulse animation function
                            function pulse() {
                                selection
                                    .transition()
                                    .duration(1000)
                                    // Only transform the radius, not the opacity
                                    .attr("r", function(d) { return getNodeSize(d) + 6; })
                                    .transition()
                                    .duration(1000)
                                    .attr("r", function(d) { return getNodeSize(d) + 5; })
                                    .on("end", pulse);
                            }
                            // Start the pulse animation
                            pulse();
                        });

                    // Add text labels to nodes
                    node.append("text")
                        .attr("class", "node-label")
                        .attr("text-anchor", "middle")
                        .attr("font-size", function(d) { 
                            if (d.isCenter) return "14px";
                            return d.layer === "priority" ? "12px" : "10px"; 
                        })
                        .attr("font-weight", function(d) { 
                            if (d.isCenter) return "bold";
                            return d.layer === "priority" ? "bold" : "normal";
                        })
                        .attr("fill", "#000000")
                        .attr("opacity", function(d) {
                            // Show all labels for priority nodes, but fewer labels for other layers
                            return d.layer === "priority" ? 1 : 0.7;
                        })
                        .text(function(d) {
                            return d.name || d.id;
                        })
                        .each(function(d) {
                            // Get label width to improve positioning
                            const bbox = this.getBBox();
                            d.labelWidth = bbox.width;
                            d.labelHeight = bbox.height;
                        });
                    
                    node.selectAll("text")
                        .each(function(d) {
                            // Get accurate bounding box for each label
                            const bbox = this.getBBox();
                            d.labelWidth = bbox.width;
                            d.labelHeight = bbox.height;
                            // Store expanded bounding box for collision detection
                            d.labelBBox = {
                                x: -bbox.width/2 - 5,  // Add padding
                                y: -bbox.height/2 - 2, // Add padding
                                width: bbox.width + 10,
                                height: bbox.height + 4
                            };
                        });
                                        
                    // Add a stronger collision detection force specifically for labels
                    simulation.force("label-collision", d3.forceCollide()
                        .radius(function(d) {
                            // Calculate collision radius based on node size and label dimensions
                            const nodeRadius = getNodeSize(d);
                            // Use the max of label width and height divided by 2 for the collision radius
                            const labelWidth = d.labelWidth || 0;
                            const labelHeight = d.labelHeight || 0;
                            const labelRadius = Math.max(labelWidth, labelHeight) / 1.8;
                            
                            // Return the larger of node radius or label radius, plus padding
                            return Math.max(nodeRadius, labelRadius) + 15;
                        })
                        .strength(0.8) // Stronger collision force specifically for labels
                        .iterations(3) 
                    );

                    // Update simulation
                    simulation.alpha(1).restart(); // Full restart for better layout
                    
                    node.isPinned = true;

                    simulation.on("tick", function() {
                        nodes.forEach(d => {
                            if (pinnedNodes.has(d.id) || d.isPinned) {
                                if (d.fx !== null && d.fy !== null) {
                                    d.x = d.fx;
                                    d.y = d.fy;
                                }
                            }
                            
                            if (pinnedNodes.has(d.id) && (d.fx === null || d.fy === null)) {
                                console.warn("Pinned node lost its fixed position:", d.id);
                            }
                            
                            if (d.isCenter) {
                                d.x = centerX;
                                d.y = centerY;
                            }

                            // Apply gentle force to keep nodes in their layer rings
                            if (!d.isCenter) {
                                // Calculate distance from center
                                const dx = d.x - centerX;
                                const dy = d.y - centerY;
                                const distance = Math.sqrt(dx * dx + dy * dy);

                                // Target radius based on layer
                                let targetRadius;
                                if (d.layer === "priority") targetRadius = 120;
                                else if (d.layer === "secondary") targetRadius = 240;
                                else targetRadius = 360; // tertiary

                                // Strength of the force (adjust as needed)
                                const strength = 0.05;

                                if (distance > 0) {
                                    // Push/pull toward the target radius
                                    const factor = 1 - (targetRadius / distance);
                                    d.x -= dx * factor * strength;
                                    d.y -= dy * factor * strength;
                                }
                            }
                        });

                        link.attr("d", function(d) {
                            const source = typeof d.source === 'object' ? d.source : nodeById.get(String(d.source));
                            const target = typeof d.target === 'object' ? d.target : nodeById.get(String(d.target));
                            
                            if (!source || !target) return "";
                            
                            // Find other links between the same nodes
                            const relatedLinks = links.filter(l => 
                                (l.source.id === source.id && l.target.id === target.id) ||
                                (l.source.id === target.id && l.target.id === source.id)
                            );
                            
                            // Calculate midpoint
                            const midX = (source.x + target.x) / 2;
                            const midY = (source.y + target.y) / 2;
                            
                            // Calculate normal vector for curve control point
                            const dx = target.x - source.x;
                            const dy = target.y - source.y;
                            const normalX = -dy;
                            const normalY = dx;
                            
                            // Normalize and scale for curvature
                            const len = Math.sqrt(normalX * normalX + normalY * normalY);
                            let curvature = 0;
                            
                            if (len > 0) {
                                // If multiple relationships, adjust curvature for each
                                const relationIndex = relatedLinks.indexOf(d);
                                const multiplier = relationIndex === 0 ? 1 : 1 + (relationIndex * 0.5);
                                curvature = 20 * multiplier;
                            }
                            
                            const controlX = midX + (normalX / len) * curvature;
                            const controlY = midY + (normalY / len) * curvature;
                            
                            // Quadratic curve path
                            return `M${source.x},${source.y} Q${controlX},${controlY} ${target.x},${target.y}`;
                        });
                        
                        node.attr("transform", function(d) {
                            return "translate(" + d.x + "," + d.y + ")";
                        });
                        
                        node.select("text")
                            .attr("dy", function(d) {
                                // Check surrounding density
                                let nearbyNodes = 0;
                                const threshold = getNodeSize(d) * 4; // Expanded detection radius
                                let crowdedTop = 0, crowdedBottom = 0, crowdedLeft = 0, crowdedRight = 0;
                                
                                nodes.forEach(other => {
                                    if (d.id !== other.id) {
                                        const dx = d.x - other.x;
                                        const dy = d.y - other.y;
                                        const distance = Math.sqrt(dx*dx + dy*dy);
                                        
                                        if (distance < threshold) {
                                            nearbyNodes++;
                                            // Check which direction is most crowded
                                            if (Math.abs(dx) > Math.abs(dy)) {
                                                // Horizontal proximity
                                                if (dx > 0) crowdedLeft++; else crowdedRight++;
                                            } else {
                                                // Vertical proximity
                                                if (dy > 0) crowdedTop++; else crowdedBottom++;
                                            }
                                        }
                                    }
                                });
                                
                                const dirs = [
                                    {dir: "top", count: crowdedTop, offset: -getNodeSize(d) - 10},
                                    {dir: "right", count: crowdedRight, offset: "0.35em"},
                                    {dir: "bottom", count: crowdedBottom, offset: getNodeSize(d) + 14},
                                    {dir: "left", count: crowdedLeft, offset: "0.35em"}
                                ];
                                
                                dirs.sort((a, b) => a.count - b.count);

                                // Adaptively position label based on node density and position
                                const angle = Math.atan2(d.y - centerY, d.x - centerX);

                                // If crowded area, place labels more carefully
                                if (d.layer === "priority" || nearbyNodes <= 2) {
                                    if (angle > -Math.PI/4 && angle < Math.PI/4) {
                                        return "0.35em"; // Right side
                                    } else if (angle >= Math.PI/4 && angle < 3*Math.PI/4) {
                                        return getNodeSize(d) + 14; // Below
                                    } else if (angle >= 3*Math.PI/4 || angle <= -3*Math.PI/4) {
                                        return "0.35em"; // Left side
                                    } else {
                                        return -getNodeSize(d) - 10; // Above
                                    }
                                }
                                
                                // Otherwise use the least crowded direction
                                return dirs[0].offset;
                            })
                            .attr("dx", function(d) {
                                // Similar to dy logic, but for horizontal positioning
                                const angle = Math.atan2(d.y - centerY, d.x - centerX);
                                
                                // Use existing dx logic but with more spacing
                                if (angle > -Math.PI/4 && angle < Math.PI/4) {
                                    return getNodeSize(d) + 8; // To the right
                                } else if (angle >= Math.PI/4 && angle < 3*Math.PI/4) {
                                    return 0; // Centered horizontally
                                } else if (angle >= 3*Math.PI/4 || angle <= -3*Math.PI/4) {
                                    return -getNodeSize(d) - 8; // To the left
                                } else {
                                    return 0; // Centered horizontally
                                }
                            })
                            .attr("text-anchor", function(d) {
                                const angle = Math.atan2(d.y - centerY, d.x - centerX);

                                // Set text anchor based on angle
                                if (angle > -Math.PI/4 && angle < Math.PI/4) {
                                    return "start"; // Right side
                                } else if (angle >= Math.PI/4 && angle < 3*Math.PI/4) {
                                    return "middle"; // Bottom
                                } else if (angle >= 3*Math.PI/4 || angle <= -3*Math.PI/4) {
                                    return "end"; // Left side
                                } else {
                                    return "middle"; // Top
                                }
                            });
                    }); 
                    
                    // Drag functions
                    function dragstarted(event, d) {
                        if (d.isCenter) return; // Don't allow dragging center node
                        if (!event.active) simulation.alphaTarget(0.3).restart();
                        // Store original position
                        d._originalX = d.x;
                        d._originalY = d.y;
                        
                        // Always fix position during drag
                        d.fx = d.x;
                        d.fy = d.y;
                    }
                            
                    function dragged(event, d) {
                        if (d.isCenter) return; // Don't allow dragging center node
                        d.fx = event.x;
                        d.fy = event.y;
                    }
                
                    function dragended(event, d) {
                        if (d.isCenter) return; // Don't allow dragging center node
                        if (!event.active) simulation.alphaTarget(0);
                        // If this node is pinned, keep it fixed at the new position
                        if (pinnedNodes.has(d.id)) {
                            d.fx = d.x;
                            d.fy = d.y;
                            console.log("Node remains pinned after drag:", d.id, "at", d.x, d.y);
                        } else {
                            // Otherwise, release it
                            d.fx = null;
                            d.fy = null;
                        }
                    }
                }
                
                function applyFocus(nodeId) {
                    console.log("Applying focus to node:", nodeId);
                    
                    // Get the focused node and its direct connections
                    const connectedNodeIds = new Set();
                    connectedNodeIds.add(nodeId); // Add the focused node itself
                    
                    // Use DOM selection to find connected nodes
                    g.selectAll(".link").each(function(link) {
                        let sourceId, targetId;
                        
                        // Handle all possible formats of source/target
                        if (typeof link.source === 'object' && link.source !== null) {
                            sourceId = link.source.id;
                        } else {
                            sourceId = String(link.source);
                        }
                        
                        if (typeof link.target === 'object' && link.target !== null) {
                            targetId = link.target.id;
                        } else {
                            targetId = String(link.target);
                        }
                        
                        // Add connected nodes to our set
                        if (sourceId === nodeId) {
                            connectedNodeIds.add(targetId);
                        }
                        if (targetId === nodeId) {
                            connectedNodeIds.add(sourceId);
                        }
                    });
                                        
                    // Apply fading and highlighting using DOM selections
                    g.selectAll(".node").classed("faded", function(d) {
                        return !connectedNodeIds.has(d.id);
                    });
                    
                    g.selectAll(".pulse-ring").each(function() {
                        const ringNodeId = d3.select(this).attr("data-node-id");
                        
                        // Set appropriate opacity based on connection
                        if (connectedNodeIds.has(ringNodeId)) {
                            d3.select(this).style("opacity", 0.5);  // Connected - visible
                            
                            // Clear any fading class if present
                            d3.select(this).classed("faded-ring", false);
                        } else {
                            d3.select(this).style("opacity", 0.01);  // Not connected - faded
                            
                            // Add class to mark as faded
                            d3.select(this).classed("faded-ring", true);
                        }
                    });
                    
                    g.selectAll(".link").classed("faded", function(d) {
                        let sourceId, targetId;
                        
                        if (typeof d.source === 'object' && d.source !== null) {
                            sourceId = d.source.id;
                        } else {
                            sourceId = String(d.source);
                        }
                        
                        if (typeof d.target === 'object' && d.target !== null) {
                            targetId = d.target.id;
                        } else {
                            targetId = String(d.target);
                        }
                        
                        return !(connectedNodeIds.has(sourceId) && connectedNodeIds.has(targetId));
                    });
                    
                    // Highlight the focused node
                    g.selectAll(".node").filter(d => d.id === nodeId).classed("focused", true);
                    
                }

                function resetFocus() {
                    console.log("Resetting focus");
                    g.selectAll(".node").classed("faded", false).classed("focused", false);
                    g.selectAll(".link").classed("faded", false);
                    g.selectAll(".pulse-ring").style("opacity", "0.5");
                }
                
                // Button click handlers
                d3.select("#reset-btn").on("click", function() {
                    expandedNodes.clear();
                    updateVisualization();
                    sendMessageToStreamlit([]);
                });
                
                d3.select("#expand-all-btn").on("click", function() {
                    console.log("Expand All button clicked");
                    
                    // First get all nodes with hidden connections
                    const nodesWithHidden = getAllNodesWithHiddenConnections();
                    
                    // Expand them all at once
                    let expansionsAdded = 0;
                    nodesWithHidden.forEach(nodeId => {
                        if (!expandedNodes.has(nodeId)) {
                            expandedNodes.add(nodeId);
                            expansionsAdded++;
                        }
                    });
                    
                    console.log(`Added ${expansionsAdded} nodes to expanded set`);
                    console.log("Expanded nodes:", Array.from(expandedNodes));
                    
                    // Update visualization with the new expanded set
                    updateVisualization();
                    
                    // Try to communicate with Streamlit if available
                    if (window.Streamlit) {
                        try {
                            window.Streamlit.setComponentValue({expandedNodes: Array.from(expandedNodes)});
                            console.log("Sent expanded nodes to Streamlit");
                        } catch (e) {
                            console.error("Error sending to Streamlit:", e);
                        }
                    } else {
                        console.warn("Streamlit object not available");
                    }
                });
                
                d3.select("#reset-btn").on("click", function() {
                    console.log("Reset button clicked");
                    
                    // Clear expanded nodes
                    const previousCount = expandedNodes.size;
                    expandedNodes.clear();
                    
                    console.log(`Cleared ${previousCount} expanded nodes`);
                    
                    // Update visualization
                    updateVisualization();
                    
                    // Try to communicate with Streamlit if available
                    if (window.Streamlit) {
                        try {
                            window.Streamlit.setComponentValue({expandedNodes: []});
                            console.log("Sent empty expanded nodes to Streamlit");
                        } catch (e) {
                            console.error("Error sending to Streamlit:", e);
                        }
                    } else {
                        console.warn("Streamlit object not available");
                    }
                });
                
                // Update the unpin button handler for gradual repositioning
                d3.select("#unpin-btn").on("click", function() {
                    console.log("Unpin All button clicked");
                    
                    if (!currentNodes || !currentSimulation) {
                        console.error("No active visualization");
                        return;
                    }
                    
                    // Store original positions before unpinning
                    const originalPositions = new Map();
                    currentNodes.forEach(node => {
                        originalPositions.set(node.id, {x: node.x, y: node.y});
                    });
                    
                    // Unpin all nodes
                    pinnedNodes.forEach(nodeId => {
                        const node = currentNodes.find(n => n.id === nodeId);
                        if (node && !node.isCenter) {
                            console.log("Unpinning node:", nodeId);
                            // Release fixed position
                            node.fx = null;
                            node.fy = null;
                        }
                    });
                    
                    // Clear pinned nodes set
                    pinnedNodes.clear();
                    
                    // Remove visual indicators
                    g.selectAll(".node--pinned").classed("node--pinned", false);
                    
                    // Reset focus as well
                    focusedNodeId = null;
                    resetFocus();
                    
                    // First stage: Gentle transition from current positions
                    currentSimulation.alpha(0.2).restart();
                    
                    // Second stage: Apply layer-based positioning after a short delay
                    setTimeout(() => {
                        // Calculate target positions based on layers
                        currentNodes.forEach(node => {
                            // Skip the center node
                            if (node.isCenter) return;
                            
                            // Calculate target radius based on layer
                            let targetRadius;
                            if (node.layer === "priority") targetRadius = 120;
                            else if (node.layer === "secondary") targetRadius = 240;
                            else targetRadius = 360; // tertiary
                            
                            // Get original position
                            const origPos = originalPositions.get(node.id);
                            if (!origPos) return;
                            
                            // Calculate angle from center
                            const dx = origPos.x - centerX;
                            const dy = origPos.y - centerY;
                            const currentAngle = Math.atan2(dy, dx);
                            
                            // Calculate new position based on layer radius
                            const newX = centerX + targetRadius * Math.cos(currentAngle);
                            const newY = centerY + targetRadius * Math.sin(currentAngle);
                            
                            // Apply a gentle pull toward the target position
                            const pullStrength = 0.1;
                            node.vx = (newX - node.x) * pullStrength;
                            node.vy = (newY - node.y) * pullStrength;
                        });
                        
                        // Run simulation with higher alpha for reorganization
                        currentSimulation.alpha(0.3).restart();
                        
                        // Reset any forces to allow natural positioning
                        setTimeout(() => {
                            currentNodes.forEach(node => {
                                // Remove velocity modifications
                                node.vx = null;
                                node.vy = null;
                            });
                            
                            // Final gentle adjustment
                            currentSimulation.alpha(0.1).restart();
                        }, 1000);
                    }, 500);
                });
                
                // Function to communicate with Streamlit
                function safelySendMessageToStreamlit(message) {
                    console.log("Attempting to send message to Streamlit:", message);
                    
                    try {
                        // Check if Streamlit is available
                        if (window.Streamlit) {
                            window.Streamlit.setComponentValue(message);
                            console.log("Message sent successfully to Streamlit");
                            return true;
                        } else {
                            console.warn("Streamlit object not available yet. Will retry in 500ms");
                            
                            // Retry after a short delay
                            setTimeout(() => {
                                if (window.Streamlit) {
                                    window.Streamlit.setComponentValue(message);
                                    console.log("Message sent successfully to Streamlit on retry");
                                } else {
                                    console.error("Streamlit object still not available after retry");
                                    
                                    // Fall back to direct update if Streamlit communication fails
                                    try {
                                        expandedNodes = new Set(message.expandedNodes || []);
                                        updateVisualization();
                                        console.log("Applied changes locally since Streamlit communication failed");
                                    } catch (localError) {
                                        console.error("Error applying local changes:", localError);
                                    }
                                }
                            }, 500);
                            return false;
                        }
                    } catch (error) {
                        console.error("Error sending message to Streamlit:", error);
                        return false;
                    }
                }
                
                function sendMessageToStreamlit(message) {
                    // Only proceed if we're in a Streamlit context
                    if (window.Streamlit && window.Streamlit.setComponentValue) {
                        try {
                            window.Streamlit.setComponentValue(message);
                            console.log("Message sent to Streamlit:", message);
                            return true;
                        } catch (e) {
                            console.error("Error sending to Streamlit:", e);
                            // No need to retry - just apply changes locally
                            console.log("Applying changes locally due to error");
                            return false;
                        }
                    } else {
                        console.log("Streamlit API not available, applying changes locally");
                        // No need to worry about it - all changes are already applied locally
                        return false;
                    }
                }
                
                svg.on("click", function(event) {
                    // Ignore if the click was on a node or a control
                    if (event.target.closest(".node") || event.target.closest(".controls")) 
                        return;
                    
                    // Reset focus
                    focusedNodeId = null;
                    resetFocus();
                    
                    // Unpin all nodes - access currentNodes instead of nodes
                    if (pinnedNodes.size > 0) {
                        pinnedNodes.forEach(nodeId => {
                            const node = currentNodes.find(n => n.id === nodeId);
                            if (node && !node.isCenter) {
                                node.fx = null;
                                node.fy = null;
                            }
                        });
                        
                        // Clear pinned nodes set
                        pinnedNodes.clear();
                        
                        // Remove visual indicators
                        g.selectAll(".node--pinned").classed("node--pinned", false);
                        
                        // Run simulation with low alpha to adjust
                        if (currentSimulation) {
                            currentSimulation.alpha(0.1).restart();
                        }
                    }
                });

                
                // Initial visualization
                updateVisualization();
                
                document.addEventListener('click', function(event) {
                    // Check if the click is outside the explanation panel and nodes
                    const explanationPanel = document.getElementById('explanation-panel');
                    const isClickOutsidePanel = explanationPanel && 
                                                !explanationPanel.contains(event.target) && 
                                                !event.target.closest('.node');
                    
                    if (isClickOutsidePanel) {
                        // Hide the explanation panel
                        d3.select("#explanation-panel").style("display", "none");
                    }
                });
            });
            </script>
        </body>
        </html>
        